/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details:
 *
 * Copyright (C) 2017 Red Hat, Inc.
 */

#include <glib.h>
#include <string.h>

#include "mm-ppp.h"
#include "mm-hdlc.h"
#include "mm-log.h"

void
_mm_log (const char *loc,
         const char *func,
         guint32 level,
         const char *fmt,
         ...)
{
#if defined ENABLE_TEST_MESSAGE_TRACES
    /* Dummy log function */
    va_list args;
    gchar *msg;

    va_start (args, fmt);
    msg = g_strdup_vprintf (fmt, args);
    va_end (args);
    g_print ("%s\n", msg);
    g_free (msg);
#endif
}

typedef struct {
    gboolean     from_host;
    gboolean     expect_error;
    const guint8 message[75];
    const guint8 expected_nak[75];
    const guint8 expected_ack[75];
} PppMessage;

static GByteArray *
ppp_to_byte_array(const guint8 *data, gsize maxlen)
{
    GByteArray *unframed, *framed;
    GError *error = NULL;
    guint i = 0;
    guint bytes_used = 0;
    gboolean need_more = FALSE;

    g_assert (maxlen > 0);
 
    /* Ignore any initial frame marker */
    if (data[0] == 0x7e) {
        data++;
        maxlen--;
    }
    while (i < maxlen && data[i++] != 0x7e);
    g_assert (i < maxlen);

    framed = g_byte_array_sized_new (i);
    g_byte_array_append (framed, data, i);
    unframed = mm_hdlc_decapsulate (framed, 0, &bytes_used, &need_more, &error);
    g_byte_array_free (framed, TRUE);
    g_assert_no_error (error);
    g_assert (unframed != NULL);
    g_assert (need_more == FALSE);
    g_assert_cmpint (bytes_used, ==, i);

    return unframed;
}

static void
test_nokia_21m02_ipv4_success_noauth (void *f, gpointer d)
{
    static const PppMessage conversation[] = {
        /* Host LCP Configuration Request and remote LCP Configuration Ack*/
        {
            .from_host = TRUE,
            .message = {
                0x7e, 0xff, 0x7d, 0x23, 0xc0, 0x21, 0x7d, 0x21, 0x7d,
                0x21, 0x7d, 0x20, 0x7d, 0x34, 0x7d, 0x22, 0x7d, 0x26,
                0x7d, 0x20, 0x7d, 0x20, 0x7d, 0x20, 0x7d, 0x20, 0x7d,
                0x25, 0x7d, 0x26, 0xfb, 0xd4, 0xc4, 0x68, 0x7d, 0x27,
                0x7d, 0x22, 0x7d, 0x28, 0x7d, 0x22, 0x30, 0x82, 0x7e
            },
            .expected_ack = {
                0x7e, 0xff, 0x7d, 0x23, 0xc0, 0x21, 0x7d, 0x22, 0x7d,
                0x21, 0x7d, 0x20, 0x7d, 0x34, 0x7d, 0x22, 0x7d, 0x26,
                0x7d, 0x20, 0x7d, 0x20, 0x7d, 0x20, 0x7d, 0x20, 0x7d,
                0x25, 0x7d, 0x26, 0xfb, 0xd4, 0xc4, 0x68, 0x7d, 0x27,
                0x7d, 0x22, 0x7d, 0x28, 0x7d, 0x22, 0xdb, 0xeb, 0x7e
            },
        },
        /* Remote LCP Configuration Request and local LCP Configuration Reject */
        {
            .from_host = FALSE,
            .message = {
                0x7e, 0xff, 0x7d, 0x23, 0xc0, 0x21, 0x7d, 0x21, 0x7d,
                0x21, 0x7d, 0x20, 0x7d, 0x3c, 0x7d, 0x21, 0x7d, 0x24,
                0x7d, 0x26, 0x40, 0x7d, 0x23, 0x7d, 0x24, 0xc0, 0x23,
                0x7d, 0x25, 0x7d, 0x26, 0xda, 0xb7, 0xab, 0x7d, 0x3f,
                0x7d, 0x22, 0x7d, 0x26, 0x7d, 0x20, 0x7d, 0x20, 0x7d,
                0x20, 0x7d, 0x20, 0x7d, 0x27, 0x7d, 0x22, 0x7d, 0x28,
                0x7d, 0x22, 0x7d, 0x39, 0x7c, 0x7e
            },
            .expected_nak = {
                0x7e, 0xff, 0x7d, 0x23, 0xc0, 0x21, 0x7d, 0x24, 0x7d,
                0x21, 0x7d, 0x20, 0x7d, 0x28, 0x7d, 0x23, 0x7d, 0x24,
                0xc0, 0x23, 0x2c, 0xd4, 0x7e, 
            },
        },
        /* Remote LCP Configuration Request and local LCP Configuration Ack */
        {
            .from_host = FALSE,
            .message = {
                0x7e, 0xff, 0x7d, 0x23, 0xc0, 0x21, 0x7d, 0x21, 0x7d,
                0x22, 0x7d, 0x20, 0x7d, 0x38, 0x7d, 0x21, 0x7d, 0x24,
                0x7d, 0x26, 0x40, 0x7d, 0x25, 0x7d, 0x26, 0xda, 0xb7,
                0xab, 0x7d, 0x3f, 0x7d, 0x22, 0x7d, 0x26, 0x7d, 0x20,
                0x7d, 0x20, 0x7d, 0x20, 0x7d, 0x20, 0x7d, 0x27, 0x7d,
                0x22, 0x7d, 0x28, 0x7d, 0x22, 0x4c, 0x30, 0x7e, 
            },
            .expected_ack = {
                0x7e, 0xff, 0x7d, 0x23, 0xc0, 0x21, 0x7d, 0x22, 0x7d,
                0x22, 0x7d, 0x20, 0x7d, 0x38, 0x7d, 0x21, 0x7d, 0x24,
                0x7d, 0x26, 0x40, 0x7d, 0x25, 0x7d, 0x26, 0xda, 0xb7,
                0xab, 0x7d, 0x3f, 0x7d, 0x22, 0x7d, 0x26, 0x7d, 0x20,
                0x7d, 0x20, 0x7d, 0x20, 0x7d, 0x20, 0x7d, 0x27, 0x7d,
                0x22, 0x7d, 0x28, 0x7d, 0x22, 0x80, 0xdd, 0x7e, 
            },
        },
        /* Remote malformed IPCP packet */
        {
            .from_host = FALSE,
            .message = {
                0x7e, 0x80, 0x21, 0x7d, 0x21, 0x7d, 0x21, 0x7d, 0x20,
                0x7d, 0x2a, 0x7d, 0x23, 0x7d, 0x26, 0x7d, 0x2a, 0x7d,
                0x20, 0x7d, 0x20, 0x7d, 0x21, 0x4a, 0x7d, 0x2b, 0x7e,
            },
        },
        /* Remote malformed IPV6CP packet */
        {
            .from_host = FALSE,
            .message = {
                0x7e, 0x80, 0x57, 0x7d, 0x21, 0x7d, 0x21, 0x7d, 0x20,
                0x7d, 0x2e, 0x7d, 0x21, 0x7d, 0x2a, 0x24, 0x56, 0x25,
                0x93, 0x7d, 0x34, 0xa6, 0x4e, 0xa8, 0xc5, 0x7d, 0x3d,
                0x7e, 
            },
        },
        /* Remote LCP Protocol Reject (spurious?) */
        {
            .from_host = FALSE,
            .message = {
                0x7e, 0xff, 0x7d, 0x23, 0xc0, 0x21, 0x7d, 0x28, 0x7d,
                0x20, 0x7d, 0x20, 0x7d, 0x36, 0x80, 0xfd, 0x7d, 0x21,
                0x7d, 0x21, 0x7d, 0x20, 0x7d, 0x2f, 0x7d, 0x3a, 0x7d,
                0x24, 0x78, 0x7d, 0x20, 0x7d, 0x38, 0x7d, 0x24, 0x78,
                0x7d, 0x20, 0x7d, 0x35, 0x7d, 0x23, 0x2f, 0x32, 0xad,
                0x7d, 0x30, 0x7e, 
            },
        },
        /* Remote malformed IPCP packet */
        {
            .from_host = FALSE,
            .message = {
                0x7e, 0x80, 0x21, 0x7d, 0x24, 0x7d, 0x21, 0x7d, 0x20,
                0x7d, 0x2a, 0x7d, 0x22, 0x7d, 0x26, 0x7d, 0x20, 0x2d,
                0x7d, 0x2f, 0x7d, 0x21, 0xf8, 0x30, 0x7e, 
            },
        },
        /* Host IPCP Configuration Request, remote IPCP Configuration Nak, and
         * remote IPCP Configuration Ack
         */
        {
            .from_host = TRUE,
            .message = {
                0x7e, 0x80, 0x21, 0x01, 0x02, 0x00, 0x0a, 0x03, 0x06,
                0x00, 0x00, 0x00, 0x00, 0x6a, 0x10, 0x7e, 
            },
            .expected_nak = {
                0x7e, 0x80, 0x21, 0x03, 0x02, 0x00, 0x0a, 0x03, 0x06,
                0x19, 0xbd, 0x60, 0x88, 0xce, 0x6a, 0x7e, 
            },
            .expected_ack = {
                0x7e, 0x80, 0x21, 0x02, 0x03, 0x00, 0x0a, 0x03, 0x06,
                0x19, 0xbd, 0x60, 0x88, 0x14, 0x0b, 0x7e, 
            },
        },
    };
    MMPpp *ppp;
    guint i;

    ppp = mm_ppp_new (MM_PPP_AUTH_NONE, NULL, NULL);
    g_assert (ppp);

    for (i = 0; i < G_N_ELEMENTS (conversation); i++) {
        GByteArray *data;
        GError *error = NULL;

        if (conversation[i].from_host) {
        } else {
            gboolean success;

            data = ppp_to_byte_array (conversation[i].message, sizeof (conversation[i].message));
            success = mm_ppp_process (ppp, data, &error);
            g_byte_array_free (data, TRUE);
            g_assert_no_error (error);
            g_assert (success);
        }
    }

    g_object_unref (ppp);
}

typedef GTestFixtureFunc TCFunc;

#define TESTCASE(t, d) g_test_create_case (#t, 0, d, NULL, (TCFunc) t, NULL)

int main (int argc, char **argv)
{
    GTestSuite *suite;
    gint result;

    g_test_init (&argc, &argv, NULL);

    suite = g_test_get_root ();

    g_test_suite_add (suite, TESTCASE (test_nokia_21m02_ipv4_success_noauth, NULL));

    result = g_test_run ();

    return result;
}
